import L from 'leaflet';
import '@elfalem/leaflet-curve';
import { MAP_CONFIG, MAP_ICONS, TILE_LAYER_CONFIG } from './map_config';

/**
 * @typedef {Object} AddMarkerOptions
 * @property {L.Icon} [icon] - The icon to use for the marker
 * @property {string} [key] - A unique identifier for the marker (autogenerated if left blank)
 * @property {string} [popup] - Text that should be shown when the marker is clicked
 */
const addMarkerDefaultOpts = {
  icon: MAP_ICONS.trip,
};

/**
 * Wrapper class for Leaflet map instances
 */
class _RoamioMap {
  /**
   * Create a Roamio map.
   * @param {string} [mapId='map'] - the HTML element ID to render the map within.
   */
  constructor(mapId = 'map') {
    this.mapId = mapId;
    this.markers = new Map(); // JavaScript map, not leaflet
    this.lines = new Map();
    this.markersFG = L.featureGroup();
    this.viewSettings = new Map();
  }

  /**
   * Creates a new Leaflet map instance and adds a tile layer
   * with configurations predefined in map_config.js.
   */
  initialise() {
    // Create a new canvas renderer for each map
    const config = { ...MAP_CONFIG, renderer: L.canvas() };
    this.map = L.map(this.mapId, config);
    this.markersFG.addTo(this.map);

    // Re-add all layers, otherwise they won't display on the map when tabbing back to it
    this.markersFG.eachLayer((layer) => {
      this.markersFG.removeLayer(layer);
      this.markersFG.addLayer(layer);
    });

    const tileLayer = L.tileLayer(TILE_LAYER_CONFIG.url, TILE_LAYER_CONFIG.options);
    this.map.addLayer(tileLayer);

    // Set any saved view settings
    if (this.viewSettings.has('coords')) {
      this.map.setView(this.viewSettings.get('coords'), this.viewSettings.get('zoom'), { animate: false });
    }

    this.map.on('moveend', this.saveView.bind(this));

    // Add Mapbox attribution
    this.addMapboxAttribution();
  }

  /**
   * Adds a marker to the map, and fits the bounds of the map such that all markers are visible
   * @param {L.LatLng} latLng - the coordinates of the marker
   * @param {AddMarkerOptions} options - options to use for the marker
   */
  addMarker(latLng, options = {}) {
    const fullOptions = { ...addMarkerDefaultOpts, ...options };

    // auto-assign key if none passed
    const markerKey = fullOptions.key || this.markers.size.toString();

    if (this.markers.has(markerKey)) {
      return;
    }

    const marker = L.marker(latLng, { icon: fullOptions.icon, riseOnHover: true });

    // Only bind a popup if the popup option is provided
    if (fullOptions.popup) {
      marker.bindPopup(fullOptions.popup);
    }

    this.markers.set(markerKey, marker);
    this.markersFG.addLayer(marker);

    // Fit map to bounds of feature group
    this.fitToFeatures();
  }

  /**
   * Remove a marker from the map
   * @param {String} key - the key of the marker to remove
   */
  removeMarker(key) {
    if (!this.markers.has(key)) {
      return;
    }

    this.markersFG.removeLayer(this.markers.get(key));
    this.markers.delete(key);
    this.fitToFeatures();
  }

  /**
   * Adds a line connecting an array of two coordinates.
   * @param latLngs {Array[L.LatLng]} - An array of the two coordinates that you want to draw a
   *                                    line between.
   * @param directionSign {number} - the sign of the direction of curve.
   *                                 If 0, then line will be straight.
   */
  addConnectingLine(latLngs, directionSign = 1, key = null) {
    // auto-assign key if none passed
    const lineKey = key || this.lines.size.toString();

    if (this.lines.has(`${lineKey}-fg`) || this.lines.has(`${lineKey}-bg`)) {
      return;
    }

    const direction = Math.sign(directionSign);

    const dashOptions = {};
    if (direction === 0) {
      dashOptions.dashArray = '30 20';
    }

    const latDiff = latLngs[1].lat - latLngs[0].lat;
    const lngDiff = latLngs[1].lng - latLngs[0].lng;
    const latOffset = 0.5 + 0.3 * -direction;
    const lngOffset = 0.5 + 0.3 * direction;

    const midPoint = L.latLng(
      latLngs[0].lat + (latOffset * latDiff),
      latLngs[0].lng + (lngOffset * lngDiff),
    );

    // Outline Curve
    const outlinePath = L.curve(
      [
        'M', [latLngs[0].lat, latLngs[0].lng],
        'Q', [midPoint.lat, midPoint.lng], [latLngs[1].lat, latLngs[1].lng],
      ],
      {
        color: '#559bf7',
        weight: 8,
        ...dashOptions,
      },
    );

    // Foreground curve
    const foregroundPath = L.curve(
      [
        'M', [latLngs[0].lat, latLngs[0].lng],
        'Q', [midPoint.lat, midPoint.lng], [latLngs[1].lat, latLngs[1].lng],
      ],
      {
        color: '#3170ef',
        weight: 6,
        ...dashOptions,
      },
    );

    this.markersFG.addLayer(outlinePath);
    this.markersFG.addLayer(foregroundPath);

    this.lines.set(`${lineKey}-fg`, foregroundPath);
    this.lines.set(`${lineKey}-bg`, outlinePath);
  }

  /**
   * Remove a connecting line from the map
   * @param {String} key - the key of the line to remove
   */
  removeConnectingLine(key) {
    if (!(this.lines.has(`${key}-fg`) || this.lines.has(`${key}-bg`))) {
      return;
    }

    this.markersFG.removeLayer(this.lines.get(`${key}-fg`));
    this.lines.delete(`${key}-fg`);
    this.markersFG.removeLayer(this.lines.get(`${key}-bg`));
    this.lines.delete(`${key}-bg`);
    this.fitToFeatures();
  }

  /**
   * Fits the map view to its features
   * @param {number} maxZoom - the zoom level to set the map to
   */
  fitToFeatures(maxZoom = 12) {
    if (this.markersFG.getLayers().length === 0) {
      this.map.setView(MAP_CONFIG.center, MAP_CONFIG.zoom);
      return;
    }
    this.map.fitBounds(this.markersFG.getBounds().pad(0.25), { maxZoom });
  }

  /**
   * Saves the current view to config
   */
  saveView() {
    this.viewSettings.set('coords', this.map.getCenter());
    this.viewSettings.set('zoom', this.map.getZoom());
  }

  /**
   * Adds Mapbox Attribution to map
   */
  addMapboxAttribution() {
    this.map.attributionControl.addAttribution(
      '© <a href="https://www.mapbox.com/about/maps">Mapbox</a> © <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> <strong><a href="https://apps.mapbox.com/feedback/" target="_blank">Improve this map</a></strong>',
    );
    const mapContainer = document.getElementById(this.mapId);
    if (mapContainer) {
      const link = document.createElement('a');
      link.href = 'https://mapbox.com/';
      link.target = '_blank';
      link.innerHTML = 'Mapbox';
      link.classList.add('mapbox-logo');
      mapContainer.appendChild(link);
    }
  }
}

/**
 * Create a new RoamioMap instance.
 * @param {string} mapId - The ID of the map element.
 * @returns {_RoamioMap} A new RoamioMap instance.
 */
function newRoamioMap(mapId) {
  return new _RoamioMap(mapId);
}

// Create and export singleton instance of RoamioMap
const RoamioMap = newRoamioMap('map');
export default RoamioMap;
export { newRoamioMap };
